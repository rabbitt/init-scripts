[[ -z "${CORES}" ]] && export CORES=$(if [ $(uname -s) = Linux ]; then grep -c ^processor /proc/cpuinfo; elif [ $(uname -s) = Darwin ]; then sysctl -n hw.ncpu; else 1; fi)
[[ "${PROMPT_COMMAND}" != *set_last_exitcode* ]] && export PROMPT_COMMAND="set_last_exitcode;${PROMPT_COMMAND}"

function jobcount() {
  [ -z "${PROMPT_IGNORE_JOBCOUNT}" ] || return

  local count=$(jobs | wc -l)
  if [ ${count} -ge 1 ]; then
    echo -en "$(white)-[$(cyan)jobs:$(bright_red)${count}$(white)]-"
  else
    echo -en "$(white)-[$(cyan)jobs:$(bright_white)0$(white)]-"
  fi
}

function is_git_repository { git branch &>/dev/null; }

function print_git_branch {
  local git_status="$(git status 2>/dev/null)"
  local state= remote_pattern= remote= diverge_pattern= branch=

  # Set color based on clean/staged/dirty.
  if [[ ${git_status} =~ "working directory clean" ]]; then
    state="${COLOR_BRIGHT_GREEN}"
  elif [[ ${git_status} =~ "Changes to be committed" ]]; then
    state="${COLOR_YELLOW}"
  else
    state="${COLOR_BRIGHT_RED}"
  fi

  # Set arrow icon based on status against remote.
  remote_pattern="Your branch is (.*) of"
  if [[ ${git_status} =~ ${remote_pattern} ]]; then
    if [[ ${BASH_REMATCH[1]} == "ahead" ]]; then
      remote="↑"
    else
      remote="↓"
    fi
  fi

  diverge_pattern="Your branch and (.*) have diverged"
  if [[ ${git_status} =~ ${diverge_pattern} ]]; then
    remote="↕"
  fi

  branch=$( git symbolic-ref --short --quiet HEAD 2>&1 )
  if [ -z "${branch}" ]; then
    hash="$(git rev-parse HEAD)"
    name=$(git name-rev --name-only ${hash})
    echo -en "$(white)-[$(cyan)detached:${state}${name} (${hash:0:7})$(white)$(yellow)${remote}$(white)]-"
  else
    # Set the final branch string.
    echo -en "$(white)-[$(cyan)branch:${state}${branch}$(white)$(yellow)${remote}$(white)]-"
  fi
}

function current_git_branch() {
  [ -z "${PROMPT_IGNORE_GIT}" ] || return
  is_git_repository && print_git_branch
}

function load_color() {
  local num="$@"
  if [ $(echo "scale=10; ${num} / ${CORES} >= 1.5" | bc) -eq 1 ]; then
    brightred ${num}
  elif [ $(echo "scale=10; ${num} / ${CORES} >= 0.8" | bc) -eq 1 ]; then
    brightyellow ${num}
  else
    brightgreen ${num}
  fi
}

function load() {
  [ -z "${PROMPT_IGNORE_LOAD}" ] || return
  local five= ten= fifteen=
  read five ten fifteen <<< $(uptime | perl -p -e 's|^.*load averages?: ||g' | tr -d ',')
  echo -en "$(white)-[$(cyan)load:$(load_color ${five}) $(load_color ${ten}) $(load_color ${fifteen})$(white)]-"
}

function lec() {
  [ -z "${PROMPT_IGNORE_LEC}" ] || return
  local status=${LEC}
  status=${status:=0}
  if [ $status -ge 1 ]; then
    echo -en "$(white)-[$(cyan)last_exit_code:$(brightred)${status}$(white)]-"
  elif [ $status -lt 0 ]; then
    echo -en "$(white)-[$(cyan)last_exit_code:$(brightyellow)${status}$(white)]-"
  else
    echo -en "$(white)-[$(cyan)last_exit_code:$(brightgreen)${status}$(white)]-"
  fi
}

function set_last_exitcode() { export LEC=$?; }

function rubyversion() {
  [ -z "${PROMPT_IGNORE_RUBY}" ] || return
  hash -d ruby &>/dev/null
  type ruby &>/dev/null

  local prog= ver= other=
  read prog ver other <<< $(ruby -v)
  echo -en "$(white)-[$(cyan)rv:$(brightgreen ${ver})$(white)]-"
}

function extras_line() {
  local extras=( "$(jobcount)" "$(lec)" "$(load)" "$(rubyversion)" "$(current_git_branch)" )
  for ((i = 0; i < ${#extras[@]}; i++)); do
    [ ! -z "${extras[$i]}" ] && echo -en "${extras[$i]} "
  done
}

function main_line() {
  local TTY=$(tty | perl -p -e 's|/dev/||g')
  local user="$(whoami)"
  local host="$(hostname -f)"
  local user_host=

  if [ "$(whoami)" = 'root' ]; then
    user="$(toupper ${user})"
    host="$(toupper ${host})"
    user_host="\n${TITLEBAR}$(white)-[$(brightred)${USER}$(yellow)@$(bright_blue)${host}$(white)]- "
  else
    user_host="\n${TITLEBAR}$(white)-[$(yellow)${USER}$(white)@$(bright_blue)${host}$(white)]- "
  fi

  echo -en "${user_host}-[$(brightblue)$(date)$(white)]- -[$(brightblack)${TTY}$(white)]-"
}

function path_line() {
  echo -en "$(white)-[$(cyan)${PWD/${HOME}/~}$(white)]-"
}

function prompt_lines() {
  [ -z "${PROMPT_IGNORE_MAIN}" ]   && echo -e "$(main_line)"
  [ -z "${PROMPT_IGNORE_EXTRAS}" ] && echo -e "$(extras_line)"
  [ -z "${PROMPT_IGNORE_PATH}" ]   && echo -e "$(path_line)"
}

function prompt() {
  export PS1="\$(prompt_lines)"
  export PS1="${PS1}\n\[$(yellow)\]\$\[$(normal_color)\] "
  export PS2="$(brightcyan)-$(cyan)-$(brightblack)-$(normal_color) "
}
