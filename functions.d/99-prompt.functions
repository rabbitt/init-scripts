[[ -z "${CORES}" ]] && export CORES=$(if [ $(uname -s) = Linux ]; then grep -c ^processor /proc/cpuinfo; elif [ $(uname -s) = Darwin ]; then sysctl -n hw.ncpu; else 1; fi)
[[ "${PROMPT_COMMAND}" != *set_last_exitcode* ]] && export PROMPT_COMMAND="set_last_exitcode;${PROMPT_COMMAND}"

function jobcount() {
  [ -z "${PROMPT_IGNORE_JOBCOUNT}" ] || return

  local count=$(jobs | wc -l)
  if [ ${count} -ge 1 ]; then
    echo -en "$(white)-[$(cyan)jobs:$(bright_red)${count}$(white)]-"
  else
    echo -en "$(white)-[$(cyan)jobs:$(bright_white)0$(white)]-"
  fi
}

function is_git_repository { git branch &>/dev/null; }

function print_git_branch {
  git_status="$(git status 2>/dev/null)"

  # Set color based on clean/staged/dirty.
  if [[ ${git_status} =~ "working directory clean" ]]; then
    state="${COLOR_BRIGHT_GREEN}"
  elif [[ ${git_status} =~ "Changes to be committed" ]]; then
    state="${COLOR_YELLOW}"
  else
    state="${COLOR_BRIGHT_RED}"
  fi

  # Set arrow icon based on status against remote.
  remote_pattern="# Your branch is (.*) of"
  if [[ ${git_status} =~ ${remote_pattern} ]]; then
    if [[ ${BASH_REMATCH[1]} == "ahead" ]]; then
      remote="↑"
    else
      remote="↓"
    fi
  fi

  diverge_pattern="# Your branch and (.*) have diverged"
  if [[ ${git_status} =~ ${diverge_pattern} ]]; then
    remote="↕"
  fi

  branch=$(
    git for-each-ref --format='%(objectname) %(refname:short)' refs/heads | \
      awk "/^$(git rev-parse HEAD)/ {print \$2}"
  )

  # Set the final branch string.
  echo -en "$(white)-[$(cyan)branch:${state}${branch}$(white)$(yellow)${remote}$(white)]-"
}

function current_git_branch() {
  [ -z "${PROMPT_IGNORE_GIT}" ] || return
  is_git_repository && print_git_branch
}

function load_color() {
  num="$@"
  if [ $(echo "scale=10; ${num} / ${CORES} >= 1.5" | bc) -eq 1 ]; then
    brightred ${num}
  elif [ $(echo "scale=10; ${num} / ${CORES} >= 0.8" | bc) -eq 1 ]; then
    brightyellow ${num}
  else
    brightgreen ${num}
  fi
}

function load() {
  [ -z "${PROMPT_IGNORE_LOAD}" ] || return
  read five ten fifteen <<< $(uptime | perl -pi -e 's|^.*load averages?: ||g' | tr -d ',')
  echo -en "$(white)-[$(cyan)load:$(load_color ${five}) $(load_color ${ten}) $(load_color ${fifteen})$(white)]-"
}

function lec() {
  [ -z "${PROMPT_IGNORE_LEC}" ] || return
  local status=${LEC}
  status=${status:=0}
  if [ $status -ge 1 ]; then
    echo -en "$(white)-[$(cyan)last_exit_code:$(brightred)${status}$(white)]-"
  elif [ $status -lt 0 ]; then
    echo -en "$(white)-[$(cyan)last_exit_code:$(brightyellow)${status}$(white)]-"
  else
    echo -en "$(white)-[$(cyan)last_exit_code:$(brightgreen)${status}$(white)]-"
  fi
}

function set_last_exitcode() { export LEC=$?; }

function rubyversion() {
  [ -z "${PROMPT_IGNORE_RUBY}" ] || return
  hash -d ruby &>/dev/null
  type ruby &>/dev/null

  read prog ver other <<< $(ruby -v)
  echo -en "$(white)-[$(cyan)rv:$(brightgreen ${ver})$(white)]-"
}

function prompt() {
  local TTY=$(tty | perl -pi -e 's|/dev/||g')
  local host="$(hostname -f)"

  if [ "$(whoami)" = 'root' ]; then
    local USERNAME="$(whoami | awk '{ print(toupper($1)) }')"
    host="$(echo ${host} | awk '{ print(toupper($1)) }')"
    PS1="\n${TITLEBAR}$(white)-[$(brightred)${USERNAME}$(yellow)@$(bright_blue)${host}$(white)]- "
  else
    PS1="\n${TITLEBAR}$(white)-[$(yellow)\u$(white)@$(bright_blue)${host}$(white)]- "
  fi

  PS1="${PS1}-[$(brightblue)\d - \A$(white)]- -[$(brightblack)${TTY}$(white)]-\n\$(jobcount) \$(lec) \$(load) \$(rubyversion) \$(current_git_branch)\n"
  PS1="${PS1}$(white)-[$(cyan)\w$(white)]-\n"
  PS1="${PS1}\[$(yellow)\]\$\[$(normal_color)\] "
  PS2="$(brightcyan)-$(cyan)-$(brightblack)-$(normal_color) "
  export PS1 PS2
}
